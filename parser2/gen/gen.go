// Generate token identifiers for all structs in parser2/token.go and
// place them in parser2/token.gen.go.
package main

import (
	"bufio"
	"bytes"
	"errors"
	"fmt"
	"go/format"
	"io"
	"log"
	"os"
	"regexp"
)

const HeaderTemplate = `// Code generated by go generate; DO NOT EDIT.
package parser2

import "github.com/golangee/tadl/token"
`

const TypeTemplate = `	Token%[1]s TokenType = "Token%[1]s"
`

const ReceiverTemplate = `
func (t *%[1]s) TokenType() TokenType {
	return Token%[1]s
}

func (t *%[1]s) Pos() *token.Position {
	return &t.Position
}
`

func main() {
	// Open input file
	fileIn, err := os.Open("token.go")
	if err != nil {
		log.Fatalf("Error while opening token.go: %v", err)
	}
	defer fileIn.Close()

	reader := bufio.NewReader(fileIn)
	nameMatcher := regexp.MustCompile("type (\\S+) struct {\n")
	tokenNames := []string{}

	// Find all struct names for tokens.
	for {
		line, err := reader.ReadString('\n')
		if errors.Is(err, io.EOF) {
			break
		}

		groups := nameMatcher.FindStringSubmatch(line)
		if len(groups) == 2 {
			tokenName := groups[1]
			tokenNames = append(tokenNames, tokenName)
		}

	}

	// Generate output source.
	var output bytes.Buffer

	output.WriteString(HeaderTemplate)

	// Write const section for TokenTypes.
	output.WriteString("\nconst (\n")
	for _, tokenName := range tokenNames {
		output.WriteString(fmt.Sprintf(TypeTemplate, tokenName))
	}
	output.WriteString(")\n")

	// Write receiver methods for tokens.
	for _, tokenName := range tokenNames {
		output.WriteString(fmt.Sprintf(ReceiverTemplate, tokenName))
	}

	// Format source.
	source := output.Bytes()
	if s, err := format.Source(source); err == nil {
		source = s
	}

	// Write output file.
	fileOut, err := os.Create("token.gen.go")
	if err != nil {
		log.Fatalf("error while creating token.gen.go: %v", err)
	}
	defer fileOut.Close()

	writer := bufio.NewWriter(fileOut)
	if _, err := writer.Write(source); err != nil {
		log.Fatalf("failed to write output file: %v", err)
	}
	writer.Flush()
}
